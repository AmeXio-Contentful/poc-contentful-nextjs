# Contentful Marketing Starter Template

![The homepage of the Marketing Starter Template](marketing-stater-template.jpg "The homepage of the Marketing Starter Template")

A ready to use Marketing website, powered by Next.js and Contentful.

---

**What is Contentful?**

[Contentful](https://www.contentful.com/) provides content infrastructure for digital teams to power websites, apps, and devices. Unlike a CMS, Contentful was built to integrate with the modern software stack. It offers a central hub for structured content, powerful management and delivery APIs, and a customizable web app that enable developers and content creators to ship their products faster.

---

## DISCLAIMER

This document outlines steps to follow as part of Contentful's Starter Templates journey.

If your sole curiosity brought you to this repository, you will not be able to get the full potential of this Starter Template until an upcoming release.

---

## Features

- Composable content through powerful & flexible content modeling
- Localization ready
- SEO ready
- Easily customizable through theming
- Generation of typed code, in sync with the API schema (content types) through GraphQL codegen

## Getting started

### Environment variables

Rename the `.env.example` file to `.env` and add the necessary values.

### Dependencies

To install the necessary dependencies, run:

```bash
yarn
```

### Run the Starter Template in development mode

```bash
yarn dev
```

The Starter Template should be up and running on `http://localhost:3000`.

## Begin your journey with Contentful and the Marketing Starter Template

Follow this [tutorial document](./docs/tutorials/contentful-and-the-starter-template.md) to understand the relationship between Contentful and the Starter Template source code.

## Contentful Components

The term _Contentful Components_ (_ctf-components_ for short) is used for react components which have an equivalent Contentful _content type_. E.g. all react components needed for rendering the _content-type_ **HeroBanner** can be found in the folder **src/ctf-components/ctf-hero-banner**.

Usually a _ctf-component_ is composed of 3 files:

- **ctf-[contentypeName].graphql** (holding the query strings needed for the graphql request to fetch the components data)
- **ctf-[contentypeName]-gql.tsx** (react component which executes the graphql query and passes the result to a component for rendering)
- **ctf-[contentypeName].tsx** (the react component which is actually rendering the content type)

and (optionally) a folder with typescript interfaces which were generated by graphql codegen:

- **/\_\_generated/** (see [GraphQL implementation & code generation](#GraphQL implementation & code generation))

### Component Resolver and content type mapping

There is a _component-resolver_ (_./src/components/component-resolver.tsx_) react component, which is used to pick the right react component for rendering a _content-type_. It requires as properties the _content type_ `id`, its `__typename`, `internalName` (used by xray mode), and optionally the content. The **component-resolver** then uses a key map to find the right react component (**./src/mappings.ts**), where the key is the _content type_ name and the value is the react component.

It will check the map `componentMap` first, and if the _content type_ could be resolved it is assumed all content is available. The content is then passed to the react component.

If the _content type_ could not be resolved, `componentGqlMap` will be used for resolving. If the react component is found the _content type_ `id`, `__typename`, and `internalName` will be passed, which is used by the component to fetch its data.

According to this pattern, all _ctf-components_ suffixed with **-gql** should be added to `componentGqlMap` and all without a suffix should be added to `componentMap`.

### Creating new Contentful Components

Creating new _ctf-components_ involves following steps:

- Create a folder for the component files (_./src/ctf-components/ctf-[contentTypeName]_)
- Create the file for the graphql query strings (_./src/ctf-components/ctf-[contentTypeName].graphql_)
- optionally, generate typescript interfaces for the graphql result by calling `yarn graphql-codegen:generate` (see [GraphQL implementation & code generation](#GraphQL implementation & code generation)).
- create react components for rendering (**./src/ctf-components/ctf-[contentTypeName]-gql.tsx** and **./src/ctf-components/ctf-[contentTypeName].tsx**).
- Add the component to the `componentGqlMap` in _./src//mappings.ts_.

## GraphQL implementation & code generation

This project makes use of Contentful's GraphQL API for more info see: [https://www.contentful.com/developers/docs/references/graphql/](https://www.contentful.com/developers/docs/references/graphql/).  
We use `graphql-codegen` to generate a typesafe API client, utilizing React Query as the "client".

- [https://www.the-guild.dev/graphql/codegen](https://www.the-guild.dev/graphql/codegen)
- [https://tanstack.com/query/v4](https://tanstack.com/query/v4)

### Codegen

Making use of `graphql-codegen`, we generate typesafe React Query hooks co-located within our component folders. With an exception for schema files and shared GraphQL fragments.

To run our codegen, we have the following two scripts available. Both generate files, but the latter runs a watcher that will regenerate files on any change in .graphql files.

- `yarn run graphql-codegen:generate`
- `yarn run graphql-codegen:watch`

The first steps of the codegen generate files that contain the GraphQL schema, and matching typescript types. They're generated to the `src/lib/__generated` folder and ought to be committed once altered/added to the repository.

Additionally, the codegen watches .graphql files in our `src` folder, if it runs successfully it generates a `__generated` folder collocated in the folder where the .graphql file was found. One exception to this rule is the `src/lib/fragments` folder that contains shared GraphQL Fragments that are used in several other queries/fragments. The TS types for these files are generated in the same location, in a `__generated` folder and like the other files ought to be committed.

#### Config

The config for the codegen can be found in `codegen.ts` in the root of the project.

### React Query

API calls made to the Contentful GraphQL endpoint are made through React Query `useQuery` hooks. The hooks are generate from the `.graphql` files collocated within the components. The following happens:

1. `[folderName]/[fileName].graphql` file, containing a query, is detected by the codegen
2. `[folderName]/__generated/[fileName].generated.ts` is generated
3. Within the generated file, a new hook is generated with the following pattern: `use[fileName]`
4. The hook can now be imported and used within the `.ts(x)` files in the component folder

## Husky & git hooks

This repository makes use of Husky to enforce commit hooks. For more info see: [https://github.com/typicode/husky](https://github.com/typicode/husky). The config for both the pre-commit and pre-push hooks can be found in the `.husky` folder located in the root.

### Pre-commit

Before allowing a commit, we require a successful result from the TypeScript compiler (`tsc`) and our `lint-staged` script will be run. This ensures all Eslint and Prettier rules are enforced on the files that are staged to be committed.
The tsc command is ran separately from the `lint-staged` step, because we require the Typescript compiler to sample _all_ files. This is important to ensure that no deviating types were introduced by the codegen for example.

### Pre-push

The same two tasks are ran for pre-push, that are ran for pre-commit.

### Overriding the Husky git hooks

In case of wanting to bypass the pre-commit or pre-push hooks, pass a `--noVerify` flag to your Git commands.

⚠️ Make sure you only use this if you know why you're using it. ⚠️
